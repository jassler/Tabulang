package de.hskempten.tabulang.astNodes.helper;

import de.hskempten.tabulang.interpreter.Interpretation;
import de.hskempten.tabulang.astNodes.Node;
import de.hskempten.tabulang.astNodes.statement.group.GroupNode;
import de.hskempten.tabulang.astNodes.term.IdentifierNode;
import de.hskempten.tabulang.astNodes.term.TermNode;
import de.hskempten.tabulang.datatypes.InternalDataObject;
import de.hskempten.tabulang.datatypes.InternalString;
import de.hskempten.tabulang.datatypes.Tuple;
import de.hskempten.tabulang.datatypes.exceptions.IllegalTupleArgumentException;
import de.hskempten.tabulang.tokenizer.TextPosition;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;

public class LoopHelper {

    /**
     * Class that handles the functionality of a loop since multiple nodes generated by the parser use this method.
     * Loops over a set of statements once for each element in a tuple.
     *
     * @return tuple of mapValue values for each iteration or a rearranged variation thereof if the set of statements contains a group statement.
     * See {@link GroupNode} for more details.
     * @throws IllegalTupleArgumentException if no tuple was specified
     */
    public static Object loop(IdentifierNode identifierNode, TermNode term, ArrayList<Node> statements, int nestingLevel, boolean groupStatementFound, Interpretation interpretation, TextPosition textPosition) {
        Object termObject = term.evaluateNode(interpretation);

        if (!(termObject instanceof Tuple<?> tuple))
            throw new IllegalTupleArgumentException(textPosition, termObject.getClass().getSimpleName(), term.getTextPosition().getContent());

        String identifier = identifierNode.getIdentifier();
        LinkedList<Object> resultList = new LinkedList<>();
        Interpretation nestedInterpretation = new Interpretation(interpretation, new HashMap<>());

        for (int i = 0; i < tuple.getElements().size(); ++i) {
            Object tupleElementObject = tuple.getElements().get(i);
            nestedInterpretation.getEnvironment().put(identifier, tupleElementObject);

            if (tupleElementObject instanceof Tuple<?> tupleElement) {
                for (int j = 0; j < tupleElement.getElements().size(); j++) {
                    InternalString type = tupleElement.getNames().getNames().get(j);
                    Object element = tupleElement.getElements().get(j);
                    nestedInterpretation.getEnvironment().put(type.getString(), element);
                }
            }
            for (Node statementNode : statements) {
                if (statementNode instanceof GroupNode && !groupStatementFound) {
                    ((GroupNode) statementNode).setNestingLevel(nestingLevel);
                    ((GroupNode) statementNode).setLastIteration(false);
                    groupStatementFound = true;
                }
                if (statementNode instanceof GroupNode && i + 1 == tuple.getElements().size()) {
                    ((GroupNode) statementNode).setLastIteration(true);
                    resultList = (LinkedList<Object>) statementNode.evaluateNode(nestedInterpretation);
                } else {
                    statementNode.evaluateNode(nestedInterpretation);
                }
            }
            if (!groupStatementFound) {
                if (nestedInterpretation.getEnvironment().containsKey("mapValue" + nestingLevel)) {
                    resultList.add(nestedInterpretation.getEnvironment().get("mapValue" + nestingLevel));
                }
            }
        }
        ArrayList<InternalDataObject> annotatedResults = new ArrayList<>(resultList.size());
        resultList.forEach(el -> annotatedResults.add(new InternalDataObject(el)));
        return new Tuple<>(annotatedResults);
    }
}
