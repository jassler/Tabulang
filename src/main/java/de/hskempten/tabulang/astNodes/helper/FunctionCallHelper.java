package de.hskempten.tabulang.astNodes.helper;

import de.hskempten.tabulang.interpreter.Interpretation;
import de.hskempten.tabulang.astNodes.Node;
import de.hskempten.tabulang.astNodes.term.IdentifierNode;
import de.hskempten.tabulang.astNodes.term.TermNode;
import de.hskempten.tabulang.datatypes.InternalFunction;
import de.hskempten.tabulang.datatypes.InternalLibraryFunction;
import de.hskempten.tabulang.datatypes.exceptions.IllegalFunctionArgumentException;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * Class that handles the functionality of a function call since multiple nodes generated by the parser use this method.
 */
public class FunctionCallHelper {

    /**
     * Calls function with specified parameters.
     *
     * @return value of the function if it contained a return-statement, null otherwise.
     * @throws IllegalFunctionArgumentException if needed and specified parameter size is not equal
     *                                          or identifier does not refer to a function in the environment
     */
    public static Object callFunction(IdentifierNode node, Interpretation interpretation, ArrayList<TermNode> parameters) {
        Object identifier = node.evaluateNode(interpretation);

        if (identifier instanceof InternalLibraryFunction f) {
            if (f.getParameters().size() != parameters.size()) {
                throw new IllegalFunctionArgumentException("Expected " + f.getParameters().size() + " parameter(s) but got " + parameters.size() + "\n"
                        + f.formattedString(node.getIdentifier()));
            }

            Object[] objectParameters = new Object[parameters.size()];
            for (int i = 0; i < objectParameters.length; i++) {
                objectParameters[i] = parameters.get(i).evaluateNode(interpretation);
            }

            var libFunc = f.getFunction();
            return libFunc.compute(objectParameters);

        } else if (identifier instanceof InternalFunction f) {
            Interpretation nestedInterpretation = new Interpretation(interpretation, new HashMap<>());
            if (f.getParameters().size() != parameters.size())
                throw new IllegalFunctionArgumentException("Expected " + f.getParameters().size() + " parameter(s) but got " + parameters.size() + "\n"
                        + f.formattedString(node.getIdentifier()));

            for (int i = 0; i < f.getParameters().size(); i++) {
                nestedInterpretation.getEnvironment().put(f.getParameters().get(i).getIdentifier(), parameters.get(i).evaluateNode(interpretation));
            }

            for (Object statement : f.getStatements()) {
                if (nestedInterpretation.getEnvironment().containsKey("return")) {
                    break;
                }
                ((Node) statement).evaluateNode(nestedInterpretation);
            }
            if (nestedInterpretation.getEnvironment().containsKey("return")) {
                return nestedInterpretation.getEnvironment().get("return");
            }
            return null;
        } else
            throw new IllegalFunctionArgumentException("Identifier " + identifier + "does not refer to a function.");
    }
}
